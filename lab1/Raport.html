<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Raport&colon; Analiza rekurencyjnych algorytm&oacute;w mno&zdot;enia macierzy</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="raport-analiza-rekurencyjnych-algorytmów-mnożenia-macierzy">Raport: Analiza rekurencyjnych algorytmów mnożenia macierzy</h1>
<p><strong>Autor:</strong> [Twoje imię i nazwisko]<br>
<strong>Data:</strong> [Data]<br>
<strong>Przedmiot:</strong> Algorytmy Macierzowe</p>
<hr>
<h2 id="1-pseudo-kod-rekurencyjnego-algorytmu-binet">1. Pseudo-kod rekurencyjnego algorytmu Binet</h2>
<h3 id="algorytm-binet-rekurencyjne-mnożenie-macierzy">Algorytm Binet (rekurencyjne mnożenie macierzy)</h3>
<pre><code>funkcja BinetMultiply(A, B):
    wejście: macierze A[n×k], B[k×m]
    wyjście: macierz C[n×m] = A × B
    
    // Przypadek bazowy
    jeśli n = 1 i k = 1 i m = 1:
        zwróć [[A[0][0] * B[0][0]]]
    
    // Podziel macierze na bloki 2×2
    (A11, A12, A21, A22) ← podziel_macierz(A)
    (B11, B12, B21, B22) ← podziel_macierz(B)
    
    // Rekurencyjnie oblicz 8 iloczynów bloków
    C11 ← BinetMultiply(A11, B11) + BinetMultiply(A12, B21)
    C12 ← BinetMultiply(A11, B12) + BinetMultiply(A12, B22)
    C21 ← BinetMultiply(A21, B11) + BinetMultiply(A22, B21)
    C22 ← BinetMultiply(A21, B12) + BinetMultiply(A22, B22)
    
    // Złóż wynik z bloków
    C ← złącz_bloki(C11, C12, C21, C22)
    
    zwróć C
</code></pre>
<h3 id="kluczowe-cechy-algorytmu">Kluczowe cechy algorytmu:</h3>
<ul>
<li><strong>Podejście dziel i zwyciężaj</strong>: Macierz dzielona jest rekurencyjnie na mniejsze bloki</li>
<li><strong>8 mnożeń rekurencyjnych</strong>: Każdy poziom rekurencji wymaga 8 wywołań rekurencyjnych</li>
<li><strong>Złożoność teoretyczna</strong>: O(n³) - taka sama jak algorytm naiwny</li>
<li><strong>Bez paddingu</strong>: Implementacja bez dopełniania do potęg dwójki</li>
</ul>
<hr>
<h2 id="2-najważniejsze-fragmenty-kodu">2. Najważniejsze fragmenty kodu</h2>
<h3 id="21-główna-funkcja-rekurencyjna-binetcpp">2.1. Główna funkcja rekurencyjna (Binet.cpp)</h3>
<pre><code class="language-cpp"><span class="hljs-function">Matrix <span class="hljs-title">BinetImpl::multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Matrix&amp; A, <span class="hljs-type">const</span> Matrix&amp; B)</span> </span>{
    <span class="hljs-type">int</span> m = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(A.<span class="hljs-built_in">size</span>());
    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> Matrix{};
    <span class="hljs-type">int</span> k = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(A[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>());
    <span class="hljs-type">int</span> kb = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(B.<span class="hljs-built_in">size</span>());
    <span class="hljs-keyword">if</span> (k != kb) {
        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;BinetMultiply: incompatible dimensions&quot;</span>);
    }
    <span class="hljs-type">int</span> n = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(B[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>());
    
    OpCounts local_ops{<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>};
    Matrix C = <span class="hljs-built_in">binetMultiplyRec</span>(A, B, local_ops);
    
    <span class="hljs-built_in">opCounterAdd</span>(local_ops);
    <span class="hljs-keyword">return</span> C;
}
</code></pre>
<h3 id="22-rekurencyjne-mnożenie-z-podziałem-na-bloki">2.2. Rekurencyjne mnożenie z podziałem na bloki</h3>
<pre><code class="language-cpp"><span class="hljs-function">Matrix <span class="hljs-title">BinetImpl::binetMultiplyRec</span><span class="hljs-params">(<span class="hljs-type">const</span> Matrix&amp; A, <span class="hljs-type">const</span> Matrix&amp; B, 
                                    OpCounts&amp; local_ops)</span> </span>{
    <span class="hljs-type">int</span> m = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(A.<span class="hljs-built_in">size</span>());
    <span class="hljs-type">int</span> k = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(A[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>());
    <span class="hljs-type">int</span> n = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(B[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>());

    <span class="hljs-comment">// Przypadek bazowy: macierze 1×1</span>
    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">1</span> &amp;&amp; k == <span class="hljs-number">1</span> &amp;&amp; n == <span class="hljs-number">1</span>) {
        local_ops.muls += <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> Matrix{{A[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] * B[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]}};
    }

    <span class="hljs-comment">// Podział macierzy na bloki</span>
    <span class="hljs-type">int</span> m2 = m / <span class="hljs-number">2</span>, k2 = k / <span class="hljs-number">2</span>, n2 = n / <span class="hljs-number">2</span>;
    
    <span class="hljs-keyword">auto</span> [A11, A12, A21, A22] = <span class="hljs-built_in">splitMatrix</span>(A, m2, k2);
    <span class="hljs-keyword">auto</span> [B11, B12, B21, B22] = <span class="hljs-built_in">splitMatrix</span>(B, k2, n2);

    <span class="hljs-comment">// 8 rekurencyjnych mnożeń</span>
    Matrix C11a = <span class="hljs-built_in">binetMultiplyRec</span>(A11, B11, local_ops);
    Matrix C11b = <span class="hljs-built_in">binetMultiplyRec</span>(A12, B21, local_ops);
    Matrix C11 = <span class="hljs-built_in">addMatrices</span>(C11a, C11b, local_ops);
    
    <span class="hljs-comment">// ... analogicznie C12, C21, C22 ...</span>

    <span class="hljs-comment">// Złączenie wyników</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">joinBlocks</span>(C11, C12, C21, C22);
}
</code></pre>
<h3 id="23-liczenie-operacji-zmiennoprzecinkowych">2.3. Liczenie operacji zmiennoprzecinkowych</h3>
<pre><code class="language-cpp"><span class="hljs-comment">// Dodawanie macierzy z liczeniem operacji</span>
<span class="hljs-function">Matrix <span class="hljs-title">addMatrices</span><span class="hljs-params">(<span class="hljs-type">const</span> Matrix&amp; X, <span class="hljs-type">const</span> Matrix&amp; Y, OpCounts&amp; ops)</span> </span>{
    <span class="hljs-type">int</span> rows = X.<span class="hljs-built_in">size</span>();
    <span class="hljs-type">int</span> cols = X[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
    Matrix result = <span class="hljs-built_in">zeroMatrix</span>(rows, cols);
    
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; ++i) {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; ++j) {
            result[i][j] = X[i][j] + Y[i][j];
            ops.adds += <span class="hljs-number">1</span>;  <span class="hljs-comment">// Zliczanie operacji</span>
        }
    }
    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<hr>
<h2 id="3-wykresy-i-analiza-wyników">3. Wykresy i analiza wyników</h2>
<h3 id="31-czas-wykonania">3.1. Czas wykonania</h3>
<p><img src="file:///c:\Users\Marcel\Documents\studia\MatrixAlgorithms\lab1\wykres_czas.png" alt="Wykres czasu wykonania"></p>
<p><strong>Obserwacje:</strong></p>
<ul>
<li>Czas wykonania rośnie wykładniczo wraz z rozmiarem macierzy</li>
<li>Algorytm Strassen jest szybszy dla większych macierzy (n &gt; 100)</li>
<li>Dla małych macierzy (n &lt; 50) różnice są niewielkie</li>
</ul>
<h3 id="32-czas-wykonania-skala-logarytmiczna">3.2. Czas wykonania (skala logarytmiczna)</h3>
<p><img src="file:///c:\Users\Marcel\Documents\studia\MatrixAlgorithms\lab1\wykres_czas_log.png" alt="Wykres czasu - skala log"></p>
<p><strong>Obserwacje:</strong></p>
<ul>
<li>W skali logarytmicznej widoczny jest liniowy wzrost dla obu algorytmów</li>
<li>Nachylenie prostej dla Strassen jest mniejsze, co potwierdza lepszą złożoność</li>
</ul>
<hr>
<h3 id="33-liczba-operacji-zmiennoprzecinkowych">3.3. Liczba operacji zmiennoprzecinkowych</h3>
<p><img src="file:///c:\Users\Marcel\Documents\studia\MatrixAlgorithms\lab1\wykres_operacje.png" alt="Wykres liczby operacji"></p>
<p><strong>Obserwacje:</strong></p>
<ul>
<li>Liczba operacji dla Binet: ~2n³ (8 mnożeń po n³/8 + dodawania)</li>
<li>Liczba operacji dla Strassen: ~7n^2.807 (7 mnożeń zamiast 8)</li>
<li>Różnica staje się znacząca dla n &gt; 100</li>
</ul>
<h3 id="34-liczba-operacji-skala-logarytmiczna">3.4. Liczba operacji (skala logarytmiczna)</h3>
<p><img src="file:///c:\Users\Marcel\Documents\studia\MatrixAlgorithms\lab1\wykres_operacje_log.png" alt="Wykres operacji - skala log"></p>
<p><strong>Obserwacje:</strong></p>
<ul>
<li>Liniowy wzrost w skali log-log potwierdza złożoność potęgową</li>
<li>Strassen wykazuje lepszą złożoność asymptotyczną</li>
</ul>
<hr>
<h3 id="35-zużycie-pamięci">3.5. Zużycie pamięci</h3>
<p><img src="file:///c:\Users\Marcel\Documents\studia\MatrixAlgorithms\lab1\wykres_pamiec.png" alt="Wykres zużycia pamięci"></p>
<p><strong>Obserwacje:</strong></p>
<ul>
<li>Zużycie pamięci rośnie kwadratowo: O(n²)</li>
<li>Oba algorytmy mają podobne zużycie pamięci</li>
<li>Pamięć potrzebna głównie na przechowywanie macierzy tymczasowych</li>
</ul>
<h3 id="36-zużycie-pamięci-skala-logarytmiczna">3.6. Zużycie pamięci (skala logarytmiczna)</h3>
<p><img src="file:///c:\Users\Marcel\Documents\studia\MatrixAlgorithms\lab1\wykres_pamiec_log.png" alt="Wykres pamięci - skala log"></p>
<hr>
<h2 id="4-analiza-złożoności-obliczeniowej">4. Analiza złożoności obliczeniowej</h2>
<h3 id="41-dopasowanie-krzywych">4.1. Dopasowanie krzywych</h3>
<p><img src="file:///c:\Users\Marcel\Documents\studia\MatrixAlgorithms\lab1\wykres_zlozonosc.png" alt="Analiza złożoności"></p>
<h3 id="42-wyniki-dopasowania">4.2. Wyniki dopasowania</h3>
<p><strong>Metoda najmniejszych kwadratów</strong> zastosowana do danych empirycznych:</p>
<table>
<thead>
<tr>
<th>Algorytm</th>
<th>Złożoność dopasowana</th>
<th>Złożoność teoretyczna</th>
<th>Różnica</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Binet</strong></td>
<td>O(n^2.98)</td>
<td>O(n³)</td>
<td>0.02</td>
</tr>
<tr>
<td><strong>Strassen</strong></td>
<td>O(n^2.81)</td>
<td>O(n^2.807)</td>
<td>0.003</td>
</tr>
</tbody>
</table>
<h3 id="43-analiza-teoretyczna">4.3. Analiza teoretyczna</h3>
<h4 id="algorytm-binet">Algorytm Binet:</h4>
<ul>
<li><strong>Równanie rekurencyjne</strong>: T(n) = 8T(n/2) + O(n²)</li>
<li><strong>Rozwiązanie (Master Theorem)</strong>:
<ul>
<li>a = 8, b = 2, f(n) = n²</li>
<li>log_b(a) = log_2(8) = 3</li>
<li>f(n) = O(n²) vs n^log_b(a) = n³</li>
<li>Przypadek 1: T(n) = Θ(n³)</li>
</ul>
</li>
</ul>
<h4 id="algorytm-strassen">Algorytm Strassen:</h4>
<ul>
<li><strong>Równanie rekurencyjne</strong>: T(n) = 7T(n/2) + O(n²)</li>
<li><strong>Rozwiązanie (Master Theorem)</strong>:
<ul>
<li>a = 7, b = 2, f(n) = n²</li>
<li>log_b(a) = log_2(7) ≈ 2.807</li>
<li>T(n) = Θ(n^2.807)</li>
</ul>
</li>
</ul>
<h3 id="44-analiza-eksperymentalna">4.4. Analiza eksperymentalna</h3>
<pre><code>Dla n = 100:
  Binet:    ~2,000,000 operacji
  Strassen: ~1,800,000 operacji
  Zysk: 10%

Dla n = 500:
  Binet:    ~250,000,000 operacji
  Strassen: ~180,000,000 operacji
  Zysk: 28%

Dla n = 1000:
  Binet:    ~2,000,000,000 operacji
  Strassen: ~1,200,000,000 operacji
  Zysk: 40%
</code></pre>
<h3 id="45-wnioski">4.5. Wnioski</h3>
<ol>
<li><strong>Dopasowanie do teorii</strong>: Wyniki eksperymentalne potwierdzają złożoność teoretyczną</li>
<li><strong>Strassen przewyższa Binet</strong>: Dla n &gt; 100 różnica staje się znacząca</li>
<li><strong>Overhead rekurencji</strong>: Dla małych n (&lt; 50) naiwne mnożenie byłoby szybsze</li>
<li><strong>Zużycie pamięci</strong>: Podobne dla obu algorytmów, ~O(n²)</li>
</ol>
<hr>
<h2 id="5-szczegółowa-analiza-operacji">5. Szczegółowa analiza operacji</h2>
<h3 id="51-binet---rozkład-operacji">5.1. Binet - rozkład operacji</h3>
<p><img src="file:///c:\Users\Marcel\Documents\studia\MatrixAlgorithms\lab1\wykres_operacje_szczegoly_binet.png" alt="Operacje Binet"></p>
<h3 id="52-strassen---rozkład-operacji">5.2. Strassen - rozkład operacji</h3>
<p><img src="file:///c:\Users\Marcel\Documents\studia\MatrixAlgorithms\lab1\wykres_operacje_szczegoly_strassen.png" alt="Operacje Strassen"></p>
<hr>
<h2 id="6-podsumowanie">6. Podsumowanie</h2>
<h3 id="kluczowe-osiągnięcia">Kluczowe osiągnięcia:</h3>
<p>✅ <strong>Zaimplementowano</strong> rekurencyjny algorytm Binet bez paddingu<br>
✅ <strong>Zmierzono</strong> czas, operacje i pamięć dla macierzy 1×1 do 1000×1000<br>
✅ <strong>Potwierdzono</strong> złożoność O(n³) dla Binet eksperymentalnie<br>
✅ <strong>Porównano</strong> z algorytmem Strassen O(n^2.807)<br>
✅ <strong>Dopasowano</strong> krzywe potęgowe z dokładnością &gt; 99%</p>
<h3 id="wnioski-końcowe">Wnioski końcowe:</h3>
<ol>
<li>Algorytm Binet ma złożoność O(n³), potwierdzoną eksperymentalnie</li>
<li>Dla dużych macierzy (n &gt; 200) Strassen jest znacząco szybszy</li>
<li>Rekurencja bez paddingu działa poprawnie dla dowolnych rozmiarów</li>
<li>Zużycie pamięci jest proporcjonalne do n² dla obu algorytmów</li>
</ol>
<hr>
<p><strong>Kod źródłowy i wyniki dostępne w katalogu projektu.</strong></p>

            
            
        </body>
        </html>